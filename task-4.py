'''
ЛОСКУТНОЕ ОДЕЯЛО
'''
'''
Реализовать программу, при помощи которой трое пользователей могут
играть в «Лоскутное одеяло». Правила игры следующие: на поле, имеющем
размер 4 на 5 клеток за один ход каждый игрок должен заполнить одну
клетку своим символом. Игрок старается, чтобы его символы были как
можно дальше друг от друга. В ходе игры ведется подсчет очков: за каждое
соседство клеток с одинаковыми символами игроку, владельцу символа
добавляется одно штрафное очко. Соседними считаются клетки, имеющие
общую сторону или расположенные наискосок друг от друга. Выигрывает
тот, у кого в конце игры меньше всего штрафных очков. Взаимодействие с
программой производится через консоль. Игровое поле изображается в
виде четырех текстовых строк и перерисовывается при каждом изменении
состояния поля. При запросе данных от пользователя программа сообщает,
что ожидает от пользователя (например, координаты очередного хода) и
проверяет корректность ввода. Программа должна уметь автоматически
определять количество штрафных очков и окончание партии и ее
победителя. Сама программа НЕ ходит, т.е. не пытается заполнять клетки
символами с целью выиграть игру.
'''

def printfield(field): #Объявление функции printfield для отображения игрового поля. Принимает на вход само поле field.
    for x in field: #Перебирает каждую строку (ряды) в игровом поле.
        # Создаёт пустую строку s, в которую будет собираться текстовое представление текущей строки поля.
        s = ''
        for n in x: #Перебирает каждый элемент (клетку) в текущей строке x.
            #В зависимости от значения в клетке (n), добавляет в строку s соответствующий символ. . - пустой символ.
            if n == 0: s += '.'
            if n == 1: s += '1'
            if n == 2: s += '2'
            if n == 3: s += '3'
        print(s)


def straf(field): #для подсчёта штрафных очков.
    r = [0, 0, 0]
    #Список r для хранения штрафных очков трёх игроков. Индекс 0 соответствует игроку 1, индекс 1 — игроку 2, индекс 2 — игроку 3.
    for igr in (1, 2, 3): #Цикл по номерам игроков. Будем считать штрафы для каждого по очереди.
        k = 0 #Создаёт счётчик k для подсчёта всех соседств клеток текущего игрока.
        #Двойной цикл для перебора всех клеток поля (4 строки, 5 столбцов). stroka — индекс строки, strofa — индекс столбца.
        for stroka in range(4):
            for strofa in range(5):
                if field[stroka][strofa] == igr:
                    #Проверяет, принадлежит ли текущая клетка [stroka][strofa] текущему игроку igr. Если да, то нужно проверить всех её соседей.
                    for di in range(-1, 2):
                        for dj in range(-1, 2):
                            if di != 0 or dj != 0:
                                #Условный оператор исключает проверку самой клетки (когда смещение di=0 и dj=0). Нас интересуют только соседи.
                                #Вычисляет координаты клетки-соседа.
                                i1 = stroka + di
                                j1 = strofa + dj
                                if 0 <= i1 <= 3 and 0 <= j1 <= 4 and field[i1][j1] == igr:
                                    '''
                                    Проверяет три условия:
                                    Координата i1 находится в пределах поля (от 0 до 3).

                                    Координата j1 находится в пределах поля (от 0 до 4).

                                    Клетка с этими координатами также принадлежит текущему игроку (igr).
                                    '''
                                    k += 1
        r[igr - 1] = k // 2 #После проверки всех клеток для игрока igr, записываем результат в список r. Деление на 2 (k // 2) происходит потому, что каждое соседство было посчитано дважды
    return r

def endgame(field):
    '''
    Объявление функции endgame для проверки окончания игры. Игра заканчивается, когда всё поле заполнено.
    '''
    k = 0 #Создаёт счётчик k для подсчёта пустых клеток
    for stroka in range(4): #Двойной цикл для перебора всех клеток поля.
        for strofa in range(5):
            if field[stroka][strofa] == 0: #Если клетка пустая (0), увеличивает счётчик k.
                k += 1
    return k == 0

field = [[0] * 5, [0] * 5, [0] * 5, [0] * 5]
#Создаёт начальное игровое поле. Это список из 4 элементов, где каждый элемент — это список из 5 нулей. 
igr = 1 #номер игрока, который ходит в текущий момент. 
while True: # Запускает бесконечный цикл, который будет продолжаться, пока игра не закончится.
    print('Ход игрока', igr)
    while True: #Запускает внутренний бесконечный цикл для получения корректного хода от пользователя.
        try:
            x, y = list(map(int, input('X Y').split()))
        except:
            x, y = 10, 10
        if 1 <= x <= 4 and 1 <= y <= 5 and field[x - 1][y - 1] == 0: #Проверяет корректность хода:
            field[x - 1][y - 1] = igr #Если все проверки пройдены, помещает символ текущего игрока (igr) в выбранную клетку и выходит из внутреннего цикла ввода.
            break
        print('Некорректный ход, повторите')
    printfield(field)
    if endgame(field): #Проверяет, заполнено ли всё поле. Если да, выходит из основного игрового цикла.
        break
    igr += 1
    if igr == 4: igr = 1
r = straf(field) #После окончания основного цикла (когда поле заполнено) вызывается функция straf для подсчёта штрафных очков. Результат сохраняется в переменную r.
minr = min(r)
print(r)
winner = [i + 1 for i in range(3) if r[i] == minr]
'''
Создает список победителей (номера игроков) с помощью генератора списка.

for i in range(3) — перебирает индексы игроков (0, 1, 2).

if r[i] == minr — проверяет, равны ли штрафные очки текущего игрока минимальным.

i + 1 — преобразует индекс в номер игрока (т.к. игроки 1, 2, 3, а индексы 0, 1, 2).
'''
print('Победил', *winner)